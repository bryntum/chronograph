<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>&quot;guides/BasicFeatures&quot; | chronograph</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.js" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title">chronograph</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../globals.html">Globals</a>
				</li>
				<li>
					<a href="_guides_basicfeatures_.html">&quot;guides/BasicFeatures&quot;</a>
				</li>
			</ul>
			<h1>External module &quot;guides/BasicFeatures&quot;</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Variables</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-variable tsd-parent-kind-external-module"><a href="_guides_basicfeatures_.html#basicfeaturesguide" class="tsd-kind-icon">Basic<wbr>Features<wbr>Guide</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Variables</h2>
				<section class="tsd-panel tsd-member tsd-kind-variable tsd-parent-kind-external-module">
					<a name="basicfeaturesguide" class="tsd-anchor"></a>
					<h3><span class="tsd-flag ts-flagConst">Const</span> Basic<wbr>Features<wbr>Guide</h3>
					<div class="tsd-signature tsd-kind-icon">Basic<wbr>Features<wbr>Guide<span class="tsd-signature-symbol">:</span> <span class="tsd-signature-type">""</span><span class="tsd-signature-symbol"> = &quot;&quot;</span></div>
					<aside class="tsd-sources">
						<ul>
							<li>Defined in <a href="https://github.com/bryntum/chronograph/blob/80ce69c/src/guides/BasicFeatures.ts#L4">src/guides/BasicFeatures.ts:4</a></li>
						</ul>
					</aside>
					<div class="tsd-comment tsd-typography">
						<div class="lead">
							<a href="#chronograph-basic-features" id="chronograph-basic-features" style="color: inherit; text-decoration: none;">
								<h1>ChronoGraph basic features</h1>
							</a>
							<a href="#entityrelation-reactivity" id="entityrelation-reactivity" style="color: inherit; text-decoration: none;">
								<h2>Entity/Relation. Reactivity.</h2>
							</a>
							<p>The most convenient view on the ChronoGraph&#39;s data is a small built-in Entity/Relation framework, which is mapped to the ES6 classes.</p>
							<p>In this framework, the data is organized as a set of entities, each having a set of fields. Entities are mapped to ES6 classes and fields - to its decorated properties.  </p>
							<pre><code class="language-ts"><span class="hljs-keyword">class</span> Person <span class="hljs-keyword">extends</span> Entity.mix(Base) {
    <span class="hljs-meta">@field</span>()
    firstName       : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@field</span>()
    lastName        : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@field</span>()
    fullName        : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@calculate</span>(<span class="hljs-string">'fullName'</span>)
    calculateFullName () : <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName
    }
}

<span class="hljs-keyword">const</span> person            = Person.new({ firstName : <span class="hljs-string">'Mark'</span>, lastName : <span class="hljs-string">'Twain'</span> })

<span class="hljs-keyword">const</span> replica           = Replica.new()

replica.addEntity(markTwain)

<span class="hljs-built_in">console</span>.log(person.fullName) <span class="hljs-comment">// "Mark Twain"</span></code></pre>
							<p>Here, we&#39;ve defined a <code>Person</code> class, as an <a href="../classes/_replica_entity_.entity.html">Entity</a> <a href="_class_bettermixin_.html#mixin">mixin</a>, applied to the <a href="../classes/_class_bettermixin_.base.html">Base</a> class.</p>
							<p>The <code>Person</code> class has 3 fields - <code>firstName</code>, <code>lastName</code> and <code>fullName</code>, distinct from other properties with the <a href="_replica_entity_.html#field">@field()</a> decorator.</p>
							<p>One more decorator <a href="_replica_entity_.html#calculate">@calculate()</a> specifies, that the value of the field <code>fullName</code> is calculated in the method <code>calculateFullName</code>, based on the values of <code>firstName</code> and <code>lastName</code>.</p>
							<p>The <code>Person</code> class can be instantiated as any other class. For the type-safety purposes, it uses its own, static constructor method <a href="../classes/_class_bettermixin_.base.html#new">new</a>, provided by the <a href="../classes/_class_bettermixin_.base.html">Base</a> class. This constructor accepts a single object, corresponding to the class properties and will issue a compilation error, if you provide a non-existent property to it. Using the <a href="../classes/_class_bettermixin_.base.html">Base</a> class and its type-safe static constructor is optional, any JS class can be used instead. </p>
							<p>All data is stored in the <a href="../classes/_replica_replica_.replica.html">replica</a>, which is initially empty. You can populate it with data using the <a href="../classes/_replica_replica_.replica.html#addentity">Replica.addEntity</a> call. Once the entity &quot;enters&quot; the replica, the reactivity contract starts holding. It is that, whenever the value of <code>firstName</code> or <code>lastName</code> changes, the value of <code>fullName</code> is updated automatically.</p>
							<p>This simple idea relieves the programmer of burden of updating the outdated data - all data automatically becomes &quot;fresh&quot; and consistent, according to the specified calculation rules.  </p>
							<a href="#purity-immutability" id="purity-immutability" style="color: inherit; text-decoration: none;">
								<h2>Purity. Immutability</h2>
							</a>
							<p>However, an important expectation is that computation functions should be pure. This is important consideration to keep in mind, coming from the imperative programming world.</p>
							<p>The pure computation means, that, given the same set of input values, it should always return the same result and should not produce side effects (should not modify any state).</p>
							<p>The purity property:</p>
							<ul>
								<li><p>Allows us to make effective data updates. If none of the &quot;firstName&quot; or &quot;lastName&quot; changes, the &quot;fullName&quot; calculation will not be started. If both have changed, it will run once. </p>
								</li>
								<li><p>Also means, that computation can be restarted at any time (even if another computation is in progress)</p>
								</li>
							</ul>
							<p>Additionally, the computation functions should return immutable data (should not re-use objects but instead return a new copy every call, similar to <code>Array#concat()</code>)</p>
							<p>As a result, we avoid a massive class of bugs, which are common in the &quot;wild&quot; turing-complete imperative code.</p>
							<p>These requirements are not enforced by ChronoGraph and you can ignore them, however you should know what you are doing in this case. </p>
							<a href="#adding-and-removing-entities" id="adding-and-removing-entities" style="color: inherit; text-decoration: none;">
								<h2>Adding and removing entities</h2>
							</a>
							<p>A replica can be populated with entities using <a href="../classes/_replica_replica_.replica.html#addentity">addEntity</a> method and should be freed from them using <a href="../classes/_replica_replica_.replica.html#removeentity">removeEntity</a>. The reactivity contract becomes active only after entity has &quot;entered&quot; the replica. In the same way, once the entity is removed from the replica, reactivity contract ends.   </p>
							<pre><code class="language-ts"><span class="hljs-keyword">const</span> person            = Person.new({ firstName : <span class="hljs-string">'Mark'</span>, lastName : <span class="hljs-string">'Twain'</span> })

person.fullName === <span class="hljs-literal">undefined</span> <span class="hljs-comment">// not in replica yet</span>

<span class="hljs-keyword">const</span> replica           = Replica.new()

replica.addEntity(person)

person.fullName === <span class="hljs-string">'Mark Twain'</span> <span class="hljs-comment">// entity in replica</span>

...

replica.removeEntity(person)</code></pre>
							<a href="#reading-and-writing-data-calculated-data" id="reading-and-writing-data-calculated-data" style="color: inherit; text-decoration: none;">
								<h2>Reading and writing data. Calculated data.</h2>
							</a>
							<p>To read from or write to a field, use regular property accessors:</p>
							<pre><code class="language-ts">person.firstName    = <span class="hljs-string">'Moby'</span>
person.lastName     = <span class="hljs-string">'Dick'</span>

person.fullName === <span class="hljs-string">'Moby Dick'</span></code></pre>
							<p>For every field, there are also generated getter and setter methods:</p>
							<pre><code class="language-ts">person.setFirstName(<span class="hljs-string">'Elon'</span>)
person.setLastName(<span class="hljs-string">'Musk'</span>)

person.getFullName() === <span class="hljs-string">'Elon Musk'</span></code></pre>
							<p>Note, that if some field is calculated in a method, it will ignore the writes to it. So the field can either represent a user input (be writeable)
							or a calculated value (only readable). </p>
							<p>In the same time, when modelling complex data domains, it might be desirable to actually support both modes for the field. This happens when
								we have a set of inter-dependent fields and changing any of them, should update the others according to the business logic. This scenario
								will lead to computation cycles and requires careful and disciplined approach.
							Please refer to the <a href="_guides_advancedfeatures_.html#advancedfeaturesguide">Advanced features</a> guide for more details. </p>
							<a href="#cancelable-transactions" id="cancelable-transactions" style="color: inherit; text-decoration: none;">
								<h2>Cancelable transactions</h2>
							</a>
							<p>At any point, if something went wrong, its possible to <a href="../classes/_replica_replica_.replica.html#reject">reject</a> the current transaction. Transaction borders are marked with the <a href="../classes/_replica_replica_.replica.html#commit">commit</a> call. The end of the previous transaction immediately starts the next one. Transaction rejection resets the whole replica state to the preceding commit.</p>
							<pre><code class="language-ts">person.firstName    = <span class="hljs-string">'Elon'</span>
person.lastName     = <span class="hljs-string">'Musk'</span>

replica.commit()

person.fullName === <span class="hljs-string">'Elon Musk'</span>

person.firstName    = <span class="hljs-string">'Mark'</span>
person.lastName     = <span class="hljs-string">'Twain'</span>

replica.reject()

person.firstName === <span class="hljs-string">'Elon'</span>
person.lastName === <span class="hljs-string">'Musk'</span>
person.fullName === <span class="hljs-string">'Elon Musk'</span></code></pre>
							<p>Transaction rejection will also &quot;cancel&quot; the <a href="../classes/_replica_replica_.replica.html#addentity">addEntity</a>/<a href="../classes/_replica_replica_.replica.html#removeentity">removeEntity</a>` calls.</p>
							<a href="#undoredo" id="undoredo" style="color: inherit; text-decoration: none;">
								<h2>Undo/redo</h2>
							</a>
							<p>It is possible to revert a replica to the previous state, using the <a href="../classes/_replica_replica_.replica.html#undo">undo</a> call. Similarly, if no changes has been made to the reverted state, its possible to <a href="../classes/_replica_replica_.replica.html#redo">redo</a> back to the initial state.</p>
							<p>To enable the undo/redo functionality, you need to opt-in, by specifying a bigger than 0 value for the <a href="../classes/_replica_replica_.replica.html#historylimit">historyLimit</a> config, during replica creation. It specifies how many transactions can be reverted. </p>
							<pre><code class="language-ts"><span class="hljs-keyword">const</span> replica       = Replica.new({ historyLimit : <span class="hljs-number">10</span> })

<span class="hljs-keyword">const</span> person        = Person.new()

replica.addEntity(person)

person.firstName    = <span class="hljs-string">'Elon'</span>
person.lastName     = <span class="hljs-string">'Musk'</span>

replica.commit()

person.fullName === <span class="hljs-string">'Elon Musk'</span>

person.firstName    = <span class="hljs-string">'Mark'</span>
person.lastName     = <span class="hljs-string">'Twain'</span>

replica.commit()

person.fullName === <span class="hljs-string">'Mark Twain'</span>

replica.undo()

person.firstName === <span class="hljs-string">'Elon'</span>
person.lastName === <span class="hljs-string">'Musk'</span>
person.fullName === <span class="hljs-string">'Elon Musk'</span>

replica.redo()

person.firstName === <span class="hljs-string">'Mark'</span>
person.lastName === <span class="hljs-string">'Twain'</span>
person.fullName === <span class="hljs-string">'Mark Twain'</span></code></pre>
							<a href="#equality" id="equality" style="color: inherit; text-decoration: none;">
								<h2>Equality</h2>
							</a>
							<p>ChronoGrah optimizes the computations, based on the assumption of the purity of computation functions. If none of the inputs of some field computation has changed - there&#39;s no need to re-compute it.</p>
							<p>The &quot;has not changed&quot; fact is checked using the equality check. It can be overriden by providing a <a href="../classes/_schema_field_.field.html#equality">equality</a> config option to the <a href="../classes/_replica_identifier_.fieldidentifier.html#field">field</a>. By default equality is checked with <code>===</code> operator. </p>
							<p>For example, if we don&#39;t care about the case of the letters:</p>
							<pre><code class="language-ts"><span class="hljs-keyword">const</span> ignoreCaseCompare = (a : <span class="hljs-built_in">string</span>, b : <span class="hljs-built_in">string</span>) : <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> a.toUpperCase() === b.toUpperCase()

<span class="hljs-keyword">class</span> Person <span class="hljs-keyword">extends</span> Entity.mix(Base) {
    <span class="hljs-meta">@field</span>({ equality : ignoreCaseCompare })
    firstName       : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@field</span>({ equality : ignoreCaseCompare })
    lastName        : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@field</span>({ equality : ignoreCaseCompare })
    fullName        : <span class="hljs-built_in">string</span>

    <span class="hljs-meta">@calculate</span>(<span class="hljs-string">'fullName'</span>)
    calculateFullName () : <span class="hljs-built_in">string</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName
    }
}</code></pre>
							<p>Make sure you&#39;ve overridden this config property for composite data (data which is represented by JS objects and arrays).</p>
							<a href="#reference-and-reference-buckets" id="reference-and-reference-buckets" style="color: inherit; text-decoration: none;">
								<h2>Reference and reference buckets</h2>
							</a>
							<p>Entities often need to reference each other. Reference and reference buckets forms the Relation part of the ChronoGraph&#39;s Entity/Relation framework.  </p>
							<p>For example, lets check the <code>Book</code> entity, that has the <code>writtenBy</code> reference field (decorated with <a href="_replica_reference_.html#reference">reference</a>) with the <code>Person</code> type, containing a reference to its author.</p>
							<pre><code class="language-ts"><span class="hljs-keyword">class</span> Book <span class="hljs-keyword">extends</span> Entity.mix(Base) {
    <span class="hljs-meta">@reference</span>()
    writtenBy       : Person
}

<span class="hljs-keyword">const</span> author        = Person.new({ firstName : <span class="hljs-string">'Mark'</span>, lastName : <span class="hljs-string">'Twain'</span> })
<span class="hljs-keyword">const</span> book          = Book.new({ writtenBy : author })

replica.addEntities([ author, book ])</code></pre>
							<p>This is a simplest form of a reference to another entity. To make it a bit smarter and to answer a question - &quot;what are the books written by Mark Twain&quot;, we can use another types of fields - reference buckets, that uses <a href="_replica_referencebucket_.html#bucket">bucket</a> decorator. </p>
							<p>Buckets are unordered <code>Set</code> collections with all entities, referencing the entity of the bucket:</p>
							<pre><code class="language-ts"><span class="hljs-keyword">class</span> Author <span class="hljs-keyword">extends</span> Person {
    <span class="hljs-meta">@bucket</span>()
    books           : Set&lt;Book&gt;
}

<span class="hljs-keyword">class</span> Book <span class="hljs-keyword">extends</span> Entity.mix(Base) {
    <span class="hljs-meta">@reference</span>({ bucket : <span class="hljs-string">'books'</span> })
    writtenBy       : Author
}

<span class="hljs-keyword">const</span> markTwain         = Author.new({ firstName : <span class="hljs-string">'Mark'</span>, lastName : <span class="hljs-string">'Twain'</span> })
<span class="hljs-keyword">const</span> tomSawyer         = Book.new({ writtenBy : markTwain })

<span class="hljs-keyword">const</span> replica           = Replica.new()

replica.addEntities([ markTwain, tomSawyer ])

markTwain.books <span class="hljs-comment">// new Set([ tomSawyer ])</span></code></pre>
							<p>The reactivity contract for buckets is preserved:</p>
							<pre><code class="language-ts"><span class="hljs-keyword">const</span> huckleberryFinn   = Book.new({ writtenBy : markTwain })

replica.addEntities([ huckleberryFinn ])

markTwain.books <span class="hljs-comment">// new Set([ tomSawyer, huckleberryFinn ])</span>

tomSawyer.writtenBy     = <span class="hljs-literal">null</span>

markTwain.books <span class="hljs-comment">// new Set([ huckleberryFinn ])</span>
</code></pre>
							<p>Takeaways:</p>
							<ul>
								<li>References between the entities can be established with the special kind of fields - <a href="_replica_reference_.html#reference">reference</a> and <a href="_replica_referencebucket_.html#bucket">bucket</a>, with corresponding decorators.</li>
								<li>References are property of the <a href="../classes/_replica_entity_.entity.html">Entity</a> type (or any type that has included this mixin)  </li>
								<li>Buckets are unordered <code>Set</code> collections with all entities, referencing the entity of the bucket  </li>
							</ul>
							<a href="#lazy-and-strict-computations" id="lazy-and-strict-computations" style="color: inherit; text-decoration: none;">
								<h2>Lazy and strict computations</h2>
							</a>
							<p>The computations for some fields may be expensive and not actually needed in every transaction. We would like to compute such fields only at the time when their value is actually needed.</p>
							<p>We will call such fields - &quot;lazy&quot; and all the other - &quot;strict&quot;. The lazyness of the field is defined with its <a href="../classes/_schema_field_.field.html#lazy">lazy</a> config:</p>
							<pre><code class="language-ts"><span class="hljs-keyword">class</span> SomeClass <span class="hljs-keyword">extends</span> Entity.mix(Base) {
    <span class="hljs-meta">@field</span>()
    someProperty            : <span class="hljs-built_in">number</span>

    <span class="hljs-meta">@field</span>({ lazy : <span class="hljs-literal">true</span> })
    expensiveToCompute      : <span class="hljs-built_in">number</span>

    <span class="hljs-meta">@calculate</span>(<span class="hljs-string">'expensiveToCompute'</span>)
    calculateExpensiveToCompute () : <span class="hljs-built_in">number</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.someProperty + <span class="hljs-number">1</span>
    }
}

<span class="hljs-keyword">const</span> instance = SomeClass.new()

instance.someProperty = <span class="hljs-number">10</span> <span class="hljs-comment">// does not trigger computation of `expensiveToCompute`</span>

replica.commit() <span class="hljs-comment">// does not trigger computation of `expensiveToCompute`</span>

instance.expensiveToCompute <span class="hljs-comment">// computation happens on-demand </span></code></pre>
							<p>Potentially changed strict fields, that haven&#39;t been read, are computed in the &quot;commit&quot; call.</p>
							<p>By default all fields are strict.</p>
							<a href="#further-reading" id="further-reading" style="color: inherit; text-decoration: none;">
								<h2>Further reading</h2>
							</a>
							<p>ChronoGraph provides a lot more functionality. It supports sync/async computations, data branching, mixed computational unit and more. Continue reading to the <a href="_guides_advancedfeatures_.html#advancedfeaturesguide">Advanced features</a> guide.</p>
							<a href="#copyright-and-license" id="copyright-and-license" style="color: inherit; text-decoration: none;">
								<h2>COPYRIGHT AND LICENSE</h2>
							</a>
							<p>MIT License</p>
							<p>Copyright (c) 2018-2020 Bryntum, Nickolay Platonov</p>
						</div>
					</div>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_chrono_cycleresolver_.html">&quot;chrono/<wbr>Cycle<wbr>Resolver&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_chrono_effect_.html">&quot;chrono/<wbr>Effect&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_chrono_graph_.html">&quot;chrono/<wbr>Graph&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_chrono_identifier_.html">&quot;chrono/<wbr>Identifier&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_chrono_transaction_.html">&quot;chrono/<wbr>Transaction&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_class_bettermixin_.html">&quot;class/<wbr>Better<wbr>Mixin&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_collection_iterator_.html">&quot;collection/<wbr>Iterator&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_cycle_resolver_cycleresolver_.html">&quot;cycle_<wbr>resolver/<wbr>Cycle<wbr>Resolver&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_guides_advancedfeatures_.html">&quot;guides/<wbr>Advanced<wbr>Features&quot;</a>
					</li>
					<li class="current tsd-kind-external-module">
						<a href="_guides_basicfeatures_.html">&quot;guides/<wbr>Basic<wbr>Features&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_guides_benchmarks_.html">&quot;guides/<wbr>Benchmarks&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_guides_cycleresolver_.html">&quot;guides/<wbr>Cycle<wbr>Resolver&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_primitives_calculation_.html">&quot;primitives/<wbr>Calculation&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_replica_entity_.html">&quot;replica/<wbr>Entity&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_replica_identifier_.html">&quot;replica/<wbr>Identifier&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_replica_reference_.html">&quot;replica/<wbr>Reference&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_replica_referencebucket_.html">&quot;replica/<wbr>Reference<wbr>Bucket&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_replica_replica_.html">&quot;replica/<wbr>Replica&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_schema_entitymeta_.html">&quot;schema/<wbr>Entity<wbr>Meta&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_schema_field_.html">&quot;schema/<wbr>Field&quot;</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="_schema_schema_.html">&quot;schema/<wbr>Schema&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-variable tsd-parent-kind-external-module">
						<a href="_guides_basicfeatures_.html#basicfeaturesguide" class="tsd-kind-icon">Basic<wbr>Features<wbr>Guide</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
</body>
</html>